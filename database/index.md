### 인덱스
- 데이터베이스에서 원하는 데이터를 빠르게 검색하기 위해서 사용
- 데이터 파일과 인덱스 파일을 따로, 부가적으로 관리
- 인덱스 파일의 레코드 : <search key 값, 레코드들을 포함한 블록에 대한 포인터>  
  - 인덱스 파일을 활용하여 찾고자 하는 데이터가 어느 디스크 블록에 있는지 알수있음

### 인덱스 종류
- B+-Tree 인덱스
- hash 인덱스
  - search key 값을 해싱해서 버킷에 접근 -> 해당 버킷을 읽어 레코드가 저장된 위치를 알 수 있음 
  - 장점) 동등 비교 조건인 경우 B+-Tree보다 빠르게 검색 가능
  - 단점) 변형된 값 (해시값)을 저장하기 때문에 범위를 검색하거나 원본값을 기준으로 정렬할 수 없음

### B+-tree
- 인덱스 파일을 저장하는 자료구조 (대부분 DBMS가 사용)
- 루트부터 단말 노드까지 모든 경로의 길이가 같은 balanced tree
- leaf 노드 : search key값과 포인터를 저장 (이러한 단말 노드들이 정렬된 순서로 저장)
- non-leaf 노드 : 리프 노드를 빠르게 찾는 인덱스 역할
- hash table보다 range query를 처리하는데 유리하기 때문에 B+-tree를 사용

### index scan
- B+-Tree의 리프 노드는 연결 리스트로 서로 연결 + 정렬됨 -> 범위를 검색하는데 유리
- index range scan
  - 수직적 탐색 + 필요한 만큼만 수평적 탐색 
  - 특정 위치에서 검색을 시작해서 검색 조건을 일치하지 않는 값을 만나면 검색을 중단
    - 루트에서부터 트리를 순회하여 리프 노드에서 lower key를 찾음
    - lower key에서부터 upper key까지 순차적으로 레코드를 읽어 처리
- index full scan
  - 수직적 탐색없이 인덱스 리프 블록 처음부터 끝까지 수평적으로 탐색

### full table scan
- 데이터 파일의 모든 레코드를 순차적으로 읽어서 처리
- disk I/O 양이 많기 때문에 느림
- full table scan이 index scan보다 빠른 경우
  - index가 있으나 테이블의 데이터가 적은 경우 (테이블이 작아 인덱스를 통해 읽는 것보다 직접 테이블을 읽는 것이 더 빠르기 때문)
  - index가 있으나 조건을 만족하는 데이터가 테이블의 많은 양을 차지하는 경우
    - 선택도가 5~10% 이내인 경우 index scan이 우수함 / 그보다 클 경우 full table scan이 우수함
    - 왜?) 인덱스의 값을 이용해서 데이터를 찾는 key lookup이 비싸기 때문에 full scan의 비용이 더 적음
 
### 인덱스 사용하기
- 옵티마이저가 index scan을 하는 경우
  - 1) WHERE절에 range 조건이 있는 경우 (>, >=, <, <=, =)
  - 2) 복합 인덱스에서 첫번째 컬럼이 조건에 있는 경우
- 옵티마이저가 인덱스를 사용하지 않고 full table scan을 시도하는 경우
  - 1) WHERE절에 부정형 조건, NULL 비교가 있는 경우 (range 조건X)
  - 2) 인덱스 컬럼을 WHERE절에서 가공한 경우   

### 인덱스 생성하기 좋은 컬럼
- WHERE절에 자주 사용되는 컬럼
- JOIN시 자주 사용되는 컬럼
- 카디널리티가 높은 컬럼
- 업데이트가 빈번하지 않은 컬럼

### 다중 컬럼 인덱스 (복합 인덱스)
- 두 개 이상의 컬럼을 묶어서 인덱스를 생성 (카디널리티가 높은 순으로!)
- 첫번째 컬럼에 대해 정렬된 상태에서 두번째 컬럼에 대해 정렬됨
- 인덱스 스캔을 위해서는 where절에는 반드시 첫번째 컬럼이 조건에 있어야함

### 인덱스의 단점
- 인덱스를 많이 생성한다고 좋은 것이 아님 (SELECT만 성능 향상)
- 쿼리를 실행할 때 별도의 과정이 추가적으로 발생하기 때문
  - INSERT : 데이터, 인덱스 파일에 두번 데이터 삽입 + 정렬 과정
  - DELETE : 해당 값을 인덱스 파일에서 삭제하지 않고 사용 안한다는 표시로 남김 -> 인덱스 파일의 row 수 그대로!
  - UPDATE : DELETE → INSERT
- 복합 인덱스 생성시 카디널리티가 높은 순으로 구성하지 않으면 오히려 인덱스로 인해 성능이 안좋아질 수 있음

### 순서 인덱스
- 인덱스 파일이 특정 컬럼(search key)값에 대해 정렬된 순서로 저장
- clustering index (= primary index)
  - search key가 primary key인 경우
  - 데이터 파일이 저장된 순서와 인덱스 파일이 저장된 순서가 일치
  - 테이블당 한 개만 생성 가능
- nonclustering index (= secondary index)
  - search key가 primary key가 아닌 경우
  - 데이터 파일이 저장된 순서와 인덱스 파일이 저장된 순서가 불일치
  - 테이블당 여러 개 생성 가능

### 순서 인덱스의 형태
- 밀집 인덱스 (dense index)
  - 데이터 파일에 있는 모든 search key값으로 인덱스 엔트리를 생성
- 희소 인덱스 (sparse index)
  - 데이터 파일에 있는 일부 search key값으로 인덱스 엔트리를 생성 
  - 파일이 search key로 정렬되어 저장된 경우만 사용 가능 (clustering index) 

### 다단계 인덱스
- 릴레이션의 크기가 커지면 인덱스를 찾는데 오래 걸림
- 인덱스의 인덱스를 가지는 인덱스 = 다단계 인덱스
