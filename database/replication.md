- DB의 크기가 커지거나 DB에 트래픽이 몰릴 경우 해결방안

### Replication
- 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식
- Master Node는 쓰기 작업만 / Slave Node는 읽기 작업만 처리
- 모든 노드는 같은 스키마와 데이터를 가지고 있음
- Master와 Slave간의 데이터 무결성 검사를 하지 않는 비동기방식으로 데이터를 동기화
- 장점
  - DB 요청의 대부분이 읽기 작업이기 때문에 Replication만으로도 성능을 높일 수 있음
  - 비동기 방식으로 운영되어 지연 시간이 거의 없음
- 단점
  - 노드들 간의 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있음
  - Master 노드가 다운되면 복구 및 대처가 까다로움
  - 쓰기 작업만 엄청 많다면 성능을 높일 수 없음!!
  
### Clustering
- 여러 개의 DB를 수평적인 구조로 구축하는 방식
- Fail over 시스템을 구축하기 위해 사용 (DB 하나가 고장나면 나머지가 대신 처리)
- 모든 노드는 같은 스키마와 데이터를 가지고 있음
- 노드들간의 데이터 무결성 검사를 하는 동기 방식으로 데이터를 동기화
- 장점 
  - 노드들 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있음
  - 1개의 노드가 죽어도 다른 노드가 살아있기 때문에 시스템을 계속 운영할 수 있음 (장애X)
- 단점
  - 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replication에 비해 쓰기 성능이 떨어짐
  
### Partitioning
- 하나의 테이블이 너무 커졌으니 쪼개자!
- 모든 노드가 같은 스키마를 가지고 있지만 각각 데이터를 일부분씩 나눠가지고있음 ex) x테이블의 일부분은 A디비, x테이블의 일부분은 B디비
- 파티셔닝의 종류 (테이블을 어떻게 나누느냐)
  - 수평 단편화 (horizontal partitioning = Sharing)
    - 테이블을 수평으로 분할해서 나눠서 저장 
  - 수직 단편화 (vertical partitioning)
    - 컬럼을 나눠 새로운 테이블로 나눠서 저장 (정규화처럼)
    - 특정 컬럼이 빈번하게 참조될 때 사용
    - 한 row의 크기가 작아지면서 해당 컬럼을 저장한 여러개의 row가 캐시에 올라갈 수 있음!!

### Sharding (horiziontal partitioning)
- 데이터를 여러개의 shard로 나눠서 저장 (균일하게 저장해야함)
- shard key = 새로운 행이 추가되면 어떤 샤드로 갈지 결정하는 key (shard key가 0이면 shard0으로)
- sharding의 여러가지 방법 (샤딩 전략)
  - hash sharding (modular sharding)
    - 해시 함수를 사용하여 shard key를 결정 (해시 함수의 input은 레코드의 특정 컬럼이나 id)
    - range sharding에 비해 데이터가 균일하게 분산 / DB를 증설하면 이미 적재된 데이터의 재정렬이 필요함
    - 데이터양이 일정수준에서 유지되는 서비스에 적합
  - range sharding
    - 특정 컬럼의 값의 범위에 따라 shard key를 결정
    - DB를 증설해도 재정렬이 필요하지 않음 / 일부 DB에 데이터가 몰릴 수 있음
- 샤딩은 프로그래밍/운영적 복잡도가 높아지기 때문에 그전에 다른 해결방안을 충분히 고민해야함
  - 어떤 연산이 자주 사용되는지/언제 어떻게 트래픽이 몰리는지 먼저 파악해야함!!! 
  - scale-in을 할까?
  - Read 연산이 많다면 cache(Redis)나 replication을 할까?
  - 일부 컬럼만 자주 사용된다면 vertical partitioning
