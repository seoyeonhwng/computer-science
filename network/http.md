## HTTP (Hyper Text Transfer Protocol)

- 인터넷에서 데이터를 주고 받을 수 있는 프로토콜
- 클라이언트와 서버가 request/response 메시지를 교환
- TCP/IP를 이용하는 응용 프로토콜

### 단방향성
- 클라이언트가 서버로 요청을 보내면 이에 대한 응답을 받는 단방향 통신

### 비연결성 (connectionless)
- 한 번의 TCP 연결로 한 번의 HTTP 요청과 응답을 하고나면 TCP 연결을 끊음
- 단점) TCP 연결/종료로 인한 오버헤드
- 해결책) keep-alive 헤더 사용 (Persistent connection)

### 무상태성 (stateless)
- 이전에 주고 받았던 request/response를 기억하지 않음
- 장점) 데이터를 매우 빠르고 확실하게 처리 + 서버의 리소스 절약
- 단점) 상태를 기억해야하는 상황도 존재 (ex. 로그인)
- 이를 보완하고 상태를 기억하기 위해 cookie, seesion, token 등을 사용

### persistent connection

- TCP 연결을 계속 유지함 (connection을 재사용)
- request/response 메시지의 헤더에 "Connection: keep-alive" 를 추가해서 구현
- HTTP1.1에서는 기본적으로 지원하기 때문에 "Connection: close"으로 사용하지 않을 수 있음
- 장점) TCP 연결/종료로 인한 오버헤드 감소 + 응답 속도 빨라짐
- 단점) 서버에 연결된 모든 클라이언트의 TCP 연결이 계속 늘어나면 서버의 자원이 고갈됨 → 클라이언트의 접속이 잦은 메인 페이지는 persistent connection을 고려해야함
- HTTP pipelineing을 가능하게 함
    - response를 받을 때까지 기다리지 않고 다음 request를 보낼 수 있음
    - 문제점) 순차적으로 request를 처리하므로 먼저 온 request가 끝날때까지 기다려야함 = Head Of Line Blocking 문제

### 쿠키와 세션

- request/response 메시지에 쿠키 정보를 추가해서 클라이언트의 상태를 파악
- 쿠키의 동작 방식
    - 클라이언트가 쿠키를 가지지 않은 상태에서 서버에게 request를 전송
    - 서버는 쿠키를 발행하고 기억해둠 + response 헤더의 set-cookie에 쿠키를 붙여서 응답
    - 클라이언트는 해당 쿠키를 자신의 웹브라우저에 저장
    - 같은 요청을 하는 경우 request 헤더의 cookie에 해당 쿠키를 붙여서 전송      
    (서버에서 클라이언트가 보낸 쿠키를 확인하여 클라이언트의 이전 상태를 알 수 있음)
- Set-Cookie 속성
    - Expires=DATE : 쿠키 유효 기한 (지정되지 않은 경우는 브라우저를 닫을 때까지)
    - Secure : HTTPS로 통신하고 있는 경우에만 쿠키를 송신
    - HttpOnly : 쿠키를 자바스크립트에서 액세스하지 못하도록 제한
- 세션
    - 쿠키에는 민감한 정보를 담을 수 없기 때문에 세션을 사용함
    - 일정 시간동안 같은 브라우저로부터 들어오는 요구를 하나의 상태로 보고 그 상태를 유지함
    - 서버는 클라이언트를 식별할 수 있는 session ID를 response 헤더의 set-Cookie에 붙여서 전송
    - 클라이언트는 reqeust 헤더에 cookie에 session ID를 붙여서 전송
- 쿠키 VS 세션
    - 저장 위치 : 쿠키는 클라이언트, 세션은 서버의 메모리에 저장
    - 보안 : 쿠키는 클라이언트 로컬에 저장 + HTTP 메시지 도청 때문에 보안에 취약
    - 라이프 사이클 : 쿠키는 브라우저가 종료되어도 저장할 수 있지만 세션ID는 브라우저 단위
    - 모든 정보를 세션에 저장하면 서버의 메모리를 과도하게 사용하여 서버에 무리이므로 
    
### HTTP 메시지
- Request 메시지 : (메소드 + URI + 프로토콜 버젼) + 헤더 필드 + 엔티티
    - 메소드 : 리소스가 어떤 행동을 하기 원하는지 지시
    - URI(Uniform Resource Identifiers) : 인터넷 상의 리소스를 지정
```
GET /index.html HTTP/1.1
Host: www.hackr.jp
```

- Response 메시지 : (프로토콜 버젼 + 상태 코드 + 상태 설명) + 헤더 필드 + 바디
```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2020
Content-Length: 362
Content-Type: text/html

<html>
...
```

### HTTP 응답 코드
- 2XX : 성공, 요청이 정상적으로 이루어졌음
    - 200 OK : 응답 성공
    - 204 No Content : response에 body는 없고 헤더만 존재 (새로운 정보를 보낼 필요가 없는 경우)
- 3XX : 리다이렉션, 요청을 완료하기 위해 다른 주소로 이동해야 함
    - 304 Not Modified : 조건부 리퀘스트를 했을때 응답이 수정되지 않음 / 캐시 목적
- 4XX : 클라이언트 오류, 올바르지 않은 요청
    - 400 Bad Request : 리퀘스트 문법이 잘못됨
    - 403 Forbidden : 리퀘스트된 리소스의 액세스가 거부됨 (접근 권한 없음)
    - 404 Not Found : 리퀘스트한 리소스가 서버상에 없음
- 5XX : 서버 오류, 올바른 요청에 대해 서버의 문제로 응답 불가능함
    - 500 Internal Server Error : 서버에서 리퀘스트를 처리하는 도중에 에러 발생

---
## 웹 서버
### 가상 호스트
- 웹 서버에서 기본적으로 존재하는 호스트 외에 여러 개의 호스트를 생성할 수 있음
- 기본적으로 존재하는 메인 호스트 외의 모든 호스트를 가상 호스트라고 함
- 이름 기반의 가상 호스트
    - 하나의 IP주소에 도메인이 다른 여러 개의 가상 호스트가 존재
    - 도메인명은 DNS에 의해서 IP주소로 변환 -> 가상 호스트들은 IP주소가 같음 -> request 메시지의 Host 헤더 필드로 구분
- 포트 기반의 가상 호스트
    - 동일한 호스트에 포트 번호가 다른 여러 개의 가상 호스트가 존재

### 프록시
- 클라이언트와 서버 사이에 통신을 중계함 (리퀘스트를 서버에 전송하고, 리스폰스를 클라이언트에게 전송)
- 클라이언트와 오리진 서버 사이에서 오리진 서버의 개입없이 클라이언트의 요청을 만족시킴
- 프록시 서버를 경유할때마다 HTTP message의 via 헤더 필드에 추가
- 캐시와 보안 목적으로 사용함

### 게이트웨이
 - 다른 서버를 중계하는 서버 (다음에 있는 서버가 HTTP 서버 이외인 경우)
 - 쇼핑 사이트에서 신용 카드 결제 시스템과 연계할때 사용됨

### 캐시
- 클라이언트가 요청한 리소스를 프록시 서버와 클라이언트의 로컬 디스크에 저장 (리소스의 복사본)
- 장점) 빠른 응답과 트래픽 감소를 위해 사용
- 단점) 일관성 (유효성) 문제 발생 가능 / 캐시는 복사본이므로 원본과 달라질 수 있음
- 해결책) Conditional GET = 조건에 맞게 GET하자 = 캐시가 바뀐 경우만 GET하자
    - 1. Last-Modified로 리소스 변경 여부 확인
        - (클라이언트 or 프록시 서버)는 request 헤더에 'If-Modified-Since : date'를 담아서 보냄 (=내가 원하는 리소스가 date 이후로 바뀌었어?)
        - 오리진 서버는 response가 바뀌지 않았다면 304 Not Modified, 바뀌었다면 200 OK + 바뀐 data를 담아서 보냄  
    - 2. ETag로 리소스 변경 여부 확인
        - (클라이언트는 or 프록시 서버)는 request 헤더의 'If-None-Match'에 ETag 유효 토큰을 담아서 보냄
        - 오리진 서버는 ETag가 바뀌지 않았다면 304 Not Modified, 바뀌었다면 200 OK + 바뀐 리소스를 담아서 보냄
- 프록시 서버 (캐싱 프록시 = 캐시 서버)
    - 프록시 서버 상에 리소스 캐시를 보존 -> 같은 리소스에 리퀘스트가 온 경우 프록시 서버에서 캐시를 리턴
    - response의 Age 헤더를 통해 얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지 전달
- 클라이언트 측 캐시 (브라우저 캐시)
    - 브라우저가 유효한 캐시를 가지고 있는 경우 같은 리소스의 액세스는 로컬 디스크에서 불러옴
- Cache-Control의 max-age : 캐시가 유효하다고 판단되는 최대 시간 (Cache-Control 헤더로 클라이언트와 서버는 캐싱 동작을 지정)
- Age : 캐시가 max-age 시간 내에서 얼마나 흘렀는지 (캐시 응답때 나타남)
- Expires : 리소스의 유효 기한 날짜 / Cache-Control의 max-age가 있다면 무시됨
- ETag : 리소스를 식별하는 식별자 (URI가 같아도 리소스가 갱신되면 ETag값도 갱신됨) / response에만 존재하는 헤더
    - 캐시의 유효 기한이 지나도 리소스가 갱신되지 않았다면 요청을 새로 보낼 필요가 없음 -> ETag로 리소스 갱신 여부를 확인하자

### 헷갈리지 말자
- 쿠키는 유저 식별과 상태 관리를 위해 클라이언트 로컬에 데이터를 일시적으로 저장
- 캐시는 빠른 응답과 트래픽 감소를 위해 리소스의 사본을 프록시 서버나 클라이언트 측에 저장
