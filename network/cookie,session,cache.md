### 쿠키
- request/response 메시지에 쿠키 정보를 추가해서 클라이언트의 상태를 파악
- 쿠키의 동작 방식
    - 클라이언트가 쿠키를 가지지 않은 상태에서 서버에게 request를 전송
    - 서버는 쿠키를 발행하고 기억해둠 + response 헤더의 set-cookie에 쿠키를 붙여서 응답
    - 클라이언트는 해당 쿠키를 자신의 웹브라우저에 저장
    - 같은 요청을 하는 경우 request 헤더의 cookie에 해당 쿠키를 붙여서 전송      
    (서버에서 클라이언트가 보낸 쿠키를 확인하여 클라이언트의 이전 상태를 알 수 있음)
- Set-Cookie 속성
    - Expires=DATE : 쿠키 유효 기한 (지정되지 않은 경우는 브라우저를 닫을 때까지)
    - Secure : HTTPS로 통신하고 있는 경우에만 쿠키를 송신
    - HttpOnly : 쿠키를 자바스크립트에서 액세스하지 못하도록 제한

### 세션
- 쿠키에는 민감한 정보를 담을 수 없기 때문에 세션을 사용함
- 일정 시간동안 같은 브라우저로부터 들어오는 요구를 하나의 상태로 보고 그 상태를 유지함
- 서버는 클라이언트를 식별할 수 있는 session ID를 response 헤더의 set-Cookie에 붙여서 전송
- 클라이언트는 reqeust 헤더에 cookie에 session ID를 붙여서 전송

### 쿠키 VS 세션
- 저장 위치 : 쿠키는 클라이언트, 세션은 서버의 메모리에 저장
- 보안 : 쿠키는 클라이언트 로컬에 저장 + HTTP 메시지 도청 때문에 보안에 취약
- 라이프 사이클 : 쿠키는 브라우저가 종료되어도 저장할 수 있지만 세션ID는 브라우저 단위
- 모든 정보를 세션에 저장하면 서버의 메모리를 과도하게 사용하여 서버에 무리이므로 쿠키 사용

### 웹사이트 UV(Unique Visitor) 계산
- 특정 기간 동안 사이트에 방문한 유니크한 사용자의 수
1. 쿠키를 이용해서 계산
    - 처음 방문할때 해당 서비스에 대한 쿠키가 생성되고 쿠키가 만료될때까지 같은 사용자로 인식
    - 한계) 쿠키를 지우거나 쿠키를 사용하지 않는 유저들은 제외
2. IP주소를 이용해서 계산
    - 같은 IP주소를 사용하면 동일한 사용자로 인식
    - 한계) 공유 IP 환경에서는 서로 다른 사용자가 동일한 IP주소를 사용

---
### 웹 캐시
- 클라이언트가 요청한 리소스(정적 컨텐츠)를 다운받아 특정 위치(클라이언트, 프록시 서버)에 복사본을 저장
- 이후 동일한 리소스 요청은 서버에 요청하지 않고 내부 저장한 파일을 사용하여 빠르게 응답
- 대부분 프로그램이 동일한 데이터나 명령어에 반복해서 액세스하기 때문에 캐싱은 효율적인 아키텍쳐
- 장점) 빠른 응답과 서버 트래픽 감소를 위해 사용 (클라이언트와 서버 둘다 좋음)
- 단점) 일관성 (유효성) 문제 발생 가능 / 캐시는 복사본이므로 원본과 달라질 수 있음
- 해결책) Conditional GET = 조건에 맞게 GET하자 = 캐시가 바뀐 경우만 GET하자

### 웹 캐시의 종류
- 브라우저 캐시
    - 브라우저 또는 클라이언트의 로컬 디스크에 캐시 -> 같은 리소스의 리퀘스트가 온 경우 로컬 디스크에서 리턴
    - 캐시된 리소스를 공유하지 않는 개인에 한정된 캐시
    - 브라우저로 방문한 페이지를 재방문하는 경우 효율 극대화
- 프록시 캐시 (캐싱 프록시, 캐시 서버)
    - 프록시 서버 상에 리소스 캐시를 보존 -> 같은 리소스의 리퀘스트가 온 경우 프록시 서버에서 리턴
    - response의 Age 헤더를 통해 얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지 전달

### 캐시 관련 HTTP 메시지 헤더
- HTTP 헤더를 통해 캐시를 컨트롤 (캐시의 만료 여부 체크 + 리소스 변경 여부 체크)
- response 메시지의 헤더에 어떻게 넣느냐에 따라 캐시 동작 방식이 결정됨
- Cache-Control의 max-age : 캐시가 유효하다고 판단되는 최대 시간
- Expires : 리소스의 유효 기한 날짜 / Cache-Control의 max-age가 있다면 무시됨
    - 브라우저는 Cache-Control의 max-age나 Expires가 유효하면 캐싱하고 지났다면 validation 작업을 수행
- Age : 캐시가 프록시 서버나 브라우저에서 max-age 시간 내에서 얼마나 흘렀는지 (캐시 응답때 나타남)
- ETag : 리소스를 식별하는 식별자 (URI가 같아도 리소스가 갱신되면 ETag값도 갱신됨) / response에만 존재하는 헤더
    - 캐시의 유효 기한이 지나도 리소스가 갱신되지 않았다면 요청을 새로 보낼 필요가 없음 -> ETag로 리소스 갱신 여부를 확인하자
    
    
### Conditional GET (조건부 요청, validation)
- 리소스가 변경된 경우만 새로운 리소스를 받아옴
- Last-Modified로 리소스 변경 여부 확인 (weak)
    - (클라이언트 or 프록시 서버)는 request 헤더에 'If-Modified-Since : date'를 담아서 보냄 (=내가 원하는 리소스가 date 이후로 바뀌었어?)
    - 오리진 서버는 response가 바뀌지 않았다면 304 Not Modified, 바뀌었다면 200 OK + 바뀐 data를 담아서 보냄  
- ETag로 리소스 변경 여부 확인 (strong)
    - (클라이언트는 or 프록시 서버)는 request 헤더의 'If-None-Match'에 ETag 유효 토큰을 담아서 보냄
    - 오리진 서버는 ETag가 바뀌지 않았다면 304 Not Modified, 바뀌었다면 200 OK + 바뀐 리소스 + 새로운 ETag를 담아서 보냄
- Last-Modified와 ETag 둘 다 있다면 둘 다 검증함 


### 헷갈리지 말자
- 쿠키는 유저 식별과 상태 관리를 위해 클라이언트 로컬에 데이터를 일시적으로 저장
- 캐시는 빠른 응답과 트래픽 감소를 위해 리소스의 사본을 프록시 서버나 클라이언트 측에 저장
