### 전체적인 흐름
<img src="https://user-images.githubusercontent.com/49056225/116192641-1b846c00-a769-11eb-9b53-5a57e379ff11.png" width="700" height="500"><br>
- CPU는 매 클럭마다 두가지 일을 반복
1. 메인 메모리에서 실행 중인 사용자 프로그램의 instruction을 하나씩 읽어와서 수행
    - CPU의 PC(Program Counter)가 가리키는 instruction을 실행
    - 만약 수행해야 할 instruction이 IO작업이라면?
      - 사용자 프로그램은 IO작업을 할 수 없기 때문에 운영체제의 커널 함수를 실행 (인터럽트 발생)
      - 인터럽트가 발생하면 CPU 제어권이 운영체제로 넘어감
      - 운영체제가 인터럽트를 보고 CPU에게 device controller에게 IO작업 지시를 명령
      - device controller가 작업을 완료하고 인터럽트를 발생시켜 CPU에게 작업 완료를 알림
      - 인터럽트가 발생하면 CPU 제어권이 운영체제로 넘어감
      - 운영체제는 왜 인터럽트가 발생했는지 확인하고 필요한 작업을 수행
      - 운영체제는 다시 사용자 프로그램에게 CPU를 할당
2. interrupt line을 보고 인터럽트가 발생했는지 확인
    - 인터럽트가 발생하면 CPU 제어권을 운영체제에게 넘김 (커널 모드)
    - 발생할 수 있는 인터럽트의 종류
      - IO 장치가 CPU에게 요청사항이 있는 경우 (하드웨어 인터럽트)
      - 사용자 프로그램이 특권 명령(IO 작업)을 수행하는 경우 

### 인터럽트
- 하드웨어 인터럽트 : 하드웨어(I/O장치)가 발생시킨 인터럽트
- 소프트웨어 인터럽트 (trap)
  - system call : 사용자 프로그램이 커널 함수를 호출하는 경우
  - exception : 사용자 모드에서 CPU가 실행할 수 없는 명령어를 실행하는 경우 ex) division by zero
- 인터럽트 관련 용어
  - 인터럽트 종류마다 무슨 일을 해야하는지 운영체제 코드에 정의되어있음
  - 인터럽트 처리 루틴 (interrupt service routine) : 해당 인터럽트를 처리하는 커널 함수 (실제 코드)
  - 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음
- 현대의 운영체제는 인터럽트에 의해 구동됨
  - 인터럽트가 들어올때만 CPU가 운영체제에게 넘어가고 그 외에는 사용자 프로그램이 CPU를 사용함 
  
### mode bit
- CPU의 제어권을 누가 가지고 있는지 나타내는 비트
  - 1 : 사용자 모드 (사용자 프로그램이 수행됨) -> 제한된 명령어만 실행 가능
  - 0 : 커널 모드 (운영체제가 실행됨) -> 모든 명령어 실행 가능
- 특권 명령 : 커널 모드에서만 수행 가능한 명령 ex) I/O작업
- mode bit를 통해 사용자 프로그램이 잘못된 수행을 하지 않도록 보호할 수 있음

### 타이머
- time sharing을 구현하기 위한 장치 / 특정 프로그램이 CPU를 독점하는 것으로부터 보호
- 운영체제가 사용자 프로그램을 넘겨줄 때 타이머에 정해진 값을 할당하고 넘겨줌
- 정해진 시간이 흐른 뒤 인터럽트 발생 -> 제어권이 운영체제에게 넘어감

### Device Controller
- 해당 I/O장치를 관리하는 작은 CPU (하드웨어) / 데이터를 저장하는 local buffer를 가짐
- I/O작업이 끝나면 인터럽트로 CPU에게 작업 완료를 알림

### DMA (Direct Memory Access) controller
- CPU와 함께 메인 메모리에 접근 가능 -> I/O장치의 local buffer에서 데이터를 읽어 메인 메모리에 복사
- I/O 장치가 CPU에게 인터럽트를 너무 많이 걸어서 CPU가 방해받는 것을 방지하기 위한 장치

---
### Synchronous I/O vs Asynchronous I/O
- 동기식 입출력 (Synchronous I/O)
    - I/O 작업 요청 후 입출력 작업이 끝날때까지 사용자 프로그램이 기다림
    - 구현 방법 1 : I/O가 끝날때까지 CPU를 아무일도 하지 않고 기다림 (CPU 낭비)
    - 구현 방법 2 : I/O가 끝날때까지 해당 프로그램에게서 CPU를 빼앗고 다른 프로그램에게 CPU를 줌
        - CPU가 낭비되지 않음 / 현대에는 해당 방식으로 구현함 
- 비동기식 입출력 (Asynchronous I/O)   
    - I/O 작업 요청 후 입출력 작업이 끝날때까지 기다리지 않고 바로 CPU 제어권을 얻을 수 있음
- 동기/비동기식 둘다 I/O작업의 완료는 인터럽트를 통해 알 수 있음
